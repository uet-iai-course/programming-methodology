<!doctype html>
<html lang="vi">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Bài 2a: Cú pháp, ngữ nghĩa, tên và phạm vi</title>

  <link rel="stylesheet" href="revealjs/dist/reset.css" />
  <link rel="stylesheet" href="revealjs/dist/reveal.css" />
  <link rel="stylesheet" href="revealjs/dist/theme/white.css" />
  <link rel="stylesheet" href="plugin/highlight/monokai.css" />
  <link rel="stylesheet" href="lecture-style.css" />
</head>


<body>
  <div class="reveal">
    <div class="slides">

      <!-- Trang bìa -->
      <section>
        <section>
          <h1>Phương pháp luận lập trình</h1>
          <h3>Bài 2a: Cú pháp, ngữ nghĩa, tên và phạm vi</h3>
          <p>Trường ĐH Công nghệ – Đại học Quốc gia Hà Nội</p>
        </section>

        <section>
          <h2>Nội dung</h2>
          <ol>
            <li>Mô tả ngôn ngữ lập trình (cú pháp, ngữ nghĩa, trình biên dịch)</li>
            <li>Tên và môi trường (environment, khối, quy tắc phạm vi)</li>
          </ol>
        </section>

        <section>
          <h2>Mục tiêu buổi học</h2>
          <ul>
            <li>Hiểu các mức mô tả ngôn ngữ và vai trò của văn phạm phi ngữ cảnh</li>
            <li>Phân biệt cú pháp, ngữ nghĩa tĩnh và ngữ nghĩa động</li>
            <li>Nắm cấu trúc trình biên dịch và ngữ nghĩa hình thức (SOS)</li>
            <li>Hiểu môi trường, khối và quy tắc phạm vi tĩnh/động</li>
          </ul>
        </section>
      </section>

      <!-- PHẦN 1: MÔ TẢ NGÔN NGỮ LẬP TRÌNH -->
      <section>
        <section>
          <h1>
            <span class="text-light">1.</span><br />
            Mô tả ngôn ngữ lập trình
          </h1>
        </section>

        <section>
          <h2>Các mức mô tả ngôn ngữ</h2>
          <p>Để mô tả một ngôn ngữ lập trình, người ta thường phân tách thành nhiều mức:</p>
          <ul>
            <li><strong>Cú pháp (syntax)</strong>: cấu trúc hình thức của chương trình (chuỗi ký hiệu hợp lệ).</li>
            <li><strong>Ngữ nghĩa (semantics)</strong>: ý nghĩa của các cấu trúc khi thực thi.</li>
            <li><strong>Thực dụng (pragmatics)</strong>: mục đích và cách sử dụng các cấu trúc trong thực tế.</li>
            <li><strong>Hiện thực (implementation)</strong>: cách xây dựng máy trừu tượng cho ngôn ngữ.</li>
          </ul>
        </section>

        <section>
          <h2>Sơ đồ các mức mô tả</h2>
          <div style="display:flex;flex-direction:column;align-items:center;gap:0.5rem;font-size:0.9em;">
            <div style="border:2px solid #1E93AB;padding:0.5rem 1rem;border-radius:8px;">Cú pháp — “Chương trình có hình thức đúng không?”</div>
            <div style="border:2px solid #1E93AB;padding:0.5rem 1rem;border-radius:8px;">Ngữ nghĩa tĩnh — “Ràng buộc theo ngữ cảnh có thỏa không?”</div>
            <div style="border:2px solid #1E93AB;padding:0.5rem 1rem;border-radius:8px;">Ngữ nghĩa động — “Khi chạy, chương trình làm gì?”</div>
            <div style="border:2px solid #666;padding:0.5rem 1rem;border-radius:8px;">Thực dụng — “Dùng cấu trúc này để làm gì?”</div>
          </div>
        </section>

        <section>
          <h2>Lexicon và grammar</h2>
          <ul>
            <li><strong>Lexicon (từ vựng)</strong>: tập ký hiệu kết thúc (chữ cái, số, từ khóa, toán tử, …).</li>
            <li><strong>Grammar (ngữ pháp)</strong>: quy tắc sinh chuỗi hợp lệ; văn phạm phi ngữ cảnh dùng quy tắc dạng \(V \to w\).</li>
          </ul>
        </section>

        <section>
          <h2>Ngữ pháp và cú pháp</h2>
          <ul>
            <li><strong>Lexicon (từ vựng)</strong>: tập các “từ” cơ bản (ký hiệu kết thúc).</li>
            <li><strong>Grammar (ngữ pháp)</strong>: quy tắc ghép các từ thành câu/chương trình hợp lệ.</li>
            <li>Trong ngôn ngữ lập trình, từ vựng có thể là vô hạn (ví dụ: mọi định danh). Công cụ chuẩn để mô tả cú pháp là <strong>văn phạm phi ngữ cảnh</strong> (context-free grammar).</li>
          </ul>
        </section>

        <section>
          <h2>Văn phạm phi ngữ cảnh: Định nghĩa</h2>
          <div class="question-box">
            <div class="question-title">Định nghĩa</div>
            Một <span class="keyword">văn phạm phi ngữ cảnh</span> là bộ bốn \(G = (NT, T, R, S)\) trong đó:
            <ul style="margin-top:0.5em;">
              <li><strong>NT</strong>: tập hữu hạn ký hiệu không kết thúc (biến, loại cú pháp).</li>
              <li><strong>T</strong>: tập hữu hạn ký hiệu kết thúc.</li>
              <li><strong>R</strong>: tập quy tắc dạng \(V \to w\), với \(V \in NT\) và \(w\) là chuỗi trên \(T \cup NT\).</li>
              <li><strong>S</strong>: ký hiệu bắt đầu, \(S \in NT\).</li>
            </ul>
          </div>
        </section>

        <section>
          <h2>Ví dụ: Chuỗi đối xứng (palindrome)</h2>
          <p>Bảng chữ cái \(A = \{a, b\}\). Chuỗi đối xứng được định nghĩa đệ quy:</p>
          <ul>
            <li>Cơ sở: \(a\), \(b\) và chuỗi rỗng \(\varepsilon\) là đối xứng.</li>
            <li>Bước: Nếu \(s\) đối xứng thì \(asa\) và \(bsb\) cũng đối xứng.</li>
          </ul>
          <p>Dạng văn phạm:</p>
          <pre><code>P → a  |  b  |  ε  |  aPa  |  bPb</code></pre>
        </section>

        <section>
          <h2>Ví dụ: Biểu thức số học</h2>
          <p>\(G = (\{E, I\}, \{a, b, +, *, -, (, )\}, R, E)\) với \(R\) gồm:</p>
          <pre><code>E → I  |  E+E  |  E*E  |  E-E  |  -E  |  (E)
I → a  |  b  |  Ia  |  Ib</code></pre>
          <p>\(E\): biểu thức; \(I\): định danh (identifier).</p>
        </section>

        <section>
          <h2>Sơ đồ văn phạm phi ngữ cảnh</h2>
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem;font-size:0.85em;">
            <div style="border:1px solid #ccc;padding:0.75rem;border-radius:8px;">
              <strong>Đầu vào</strong><br/>Chuỗi ký hiệu (mã nguồn / token)
            </div>
            <div style="border:1px solid #ccc;padding:0.75rem;border-radius:8px;">
              <strong>Quy tắc R</strong><br/>V → w (V: 1 ký hiệu không kết thúc)
            </div>
            <div style="border:1px solid #1E93AB;padding:0.75rem;border-radius:8px;grid-column:1/-1;">
              <strong>Kết quả</strong>: Cây dẫn xuất (cấu trúc cú pháp) hoặc báo lỗi
            </div>
          </div>
        </section>

        <section>
          <h2>Dẫn xuất (derivation)</h2>
          <ul>
            <li><strong>Dẫn xuất trực tiếp</strong> \(v \Rightarrow w\): thay một ký hiệu không kết thúc \(V\) trong \(v\) bằng vế phải của một quy tắc \(V \to w\).</li>
            <li><strong>Dẫn xuất</strong> \(v \Rightarrow^* w\): tồn tại dãy hữu hạn dẫn xuất trực tiếp từ \(v\) đến \(w\).</li>
            <li><strong>Ngôn ngữ sinh bởi G</strong>: \(L(G) = \{ w \in T^* \mid S \Rightarrow^* w \}\).</li>
          </ul>
        </section>

        <section>
          <h2>Ví dụ dẫn xuất</h2>
          <p>Chuỗi <span class="inline-code">ab*(a+b)</span> theo văn phạm biểu thức:</p>
          <pre><code>E ⇒ E*E ⇒ I*E ⇒ ... ⇒ ab*(a+b)</code></pre>
          <p>Có thể chọn thứ tự mở rộng khác nhau (trái nhất, phải nhất) nhưng cùng mô tả cấu trúc của chuỗi.</p>
        </section>

        <section>
          <h2>Cây dẫn xuất (parse tree)</h2>
          <ul>
            <li><strong>Cây dẫn xuất</strong>: cây có gốc, mỗi nút gán nhãn trong \(NT \cup T \cup \{\varepsilon\}\).</li>
            <li>Gốc là \(S\); nút trong là ký hiệu không kết thúc; nếu nút \(A\) có con \(X_1\ldots X_k\) thì \(A \to X_1\ldots X_k \in R\).</li>
            <li>Đọc lá từ trái sang phải ta được chuỗi terminal.</li>
            <li>Hai dẫn xuất khác nhau có thể cho cùng một cây → cấu trúc chuỗi được xác định rõ ràng.</li>
          </ul>
        </section>

        <section>
          <h2>Minh họa cây dẫn xuất</h2>
          <p>Biểu thức <span class="inline-code">a*b+a</span> có thể có hai cây:</p>
          <ul>
            <li><strong>Cây 1</strong>: tổng của (a*b) và a → nhân trước, cộng sau.</li>
            <li><strong>Cây 2</strong>: tích của a và (b+a) → cộng trước, nhân sau.</li>
          </ul>
          <p>Hai cây khác nhau cho cùng chuỗi → vấn đề <strong>nhập nhằng (ambiguity)</strong>.</p>
        </section>

        <section>
          <h2>Nhập nhằng (ambiguity)</h2>
          <div class="question-box">
            <div class="question-title">Định nghĩa</div>
            Văn phạm \(G\) là <span class="keyword">nhập nhằng</span> nếu tồn tại ít nhất một chuỗi trong \(L(G)\) có nhiều hơn một cây dẫn xuất.
          </div>
          <p>Văn phạm nhập nhằng không phù hợp để mô tả ngôn ngữ lập trình vì không dịch chương trình một cách duy nhất. Có thể chuyển sang văn phạm tương đương không nhập nhằng (ví dụ: thể hiện thứ tự ưu tiên toán tử).</p>
        </section>

        <section>
          <h2>BNF (Backus–Naur Form)</h2>
          <ul>
            <li>Ký hiệu trong định nghĩa AlGOL 60: <span class="inline-code">::=</span> thay cho \(\to\), non-terminal trong \(\langle \rangle\), nhiều vế phải tách bằng <span class="inline-code">|</span>.</li>
            <li>Ví dụ: <span class="inline-code">&lt;Exp&gt; ::= &lt;Ide&gt; | &lt;Exp&gt;+&lt;Exp&gt; | &lt;Exp&gt;*&lt;Exp&gt; | ...</span></li>
          </ul>
        </section>

        <section>
          <h2>Câu hỏi nhanh – Cú pháp</h2>
          <ol>
            <li>Tại sao văn phạm nhập nhằng không phù hợp cho ngôn ngữ lập trình?</li>
            <li>Sự khác nhau giữa “dẫn xuất trực tiếp” và “dẫn xuất” (⇒ và ⇒*)?</li>
            <li>Cây dẫn xuất cho biết thông tin gì mà chuỗi ký tự không cho?</li>
          </ol>
        </section>

        <section>
          <h2>Ràng buộc cú pháp theo ngữ cảnh</h2>
          <p>Đúng cú pháp (theo văn phạm) chưa đủ để chương trình “hợp lệ”. Cần thêm ràng buộc phụ thuộc ngữ cảnh:</p>
          <ul>
            <li>Định danh phải được khai báo trước khi dùng.</li>
            <li>Số tham số thực phải bằng số tham số hình thức.</li>
            <li>Kiểu biểu thức phải tương thích với biến trong phép gán.</li>
          </ul>
          <p>Những ràng buộc này thường gọi là <strong>ngữ nghĩa tĩnh</strong> (static semantics).</p>
        </section>

        <section>
          <h2>Cú pháp vs ngữ nghĩa tĩnh vs ngữ nghĩa động</h2>
          <table>
            <thead>
              <tr><th>Khái niệm</th><th>Mô tả</th></tr>
            </thead>
            <tbody>
              <tr><td>Cú pháp</td><td>Mô tả được bằng văn phạm phi ngữ cảnh</td></tr>
              <tr><td>Ngữ nghĩa tĩnh</td><td>Ràng buộc kiểm tra được khi biên dịch (không cần chạy)</td></tr>
              <tr><td>Ngữ nghĩa động</td><td>Hành vi khi thực thi chương trình</td></tr>
            </tbody>
          </table>
        </section>

        <section>
          <h2>Sơ đồ luồng trình biên dịch</h2>
          <div style="font-size:0.8em;line-height:1.5;">
            <p><strong>Mã nguồn</strong> → Scanner → <strong>Token</strong> → Parser → <strong>Cây dẫn xuất / AST</strong> → Phân tích ngữ nghĩa (bảng ký hiệu) → <strong>Mã trung gian</strong> → Tối ưu → <strong>Mã đích</strong></p>
          </div>
          <p>Lexical và syntax thường đan xen: scanner cung cấp token khi parser cần.</p>
        </section>

        <section>
          <h2>Cấu trúc trình biên dịch (tổng quan)</h2>
          <p>Trình biên dịch thường gồm nhiều giai đoạn xử lý nối tiếp:</p>
          <ol>
            <li><strong>Phân tích từ vựng (lexical analysis)</strong>: nguồn → danh sách token.</li>
            <li><strong>Phân tích cú pháp (syntax analysis)</strong>: token → cây dẫn xuất.</li>
            <li><strong>Phân tích ngữ nghĩa</strong>: kiểm tra ràng buộc ngữ cảnh, bổ sung thông tin (kiểu, bảng ký hiệu).</li>
            <li><strong>Sinh mã trung gian / tối ưu / sinh mã đích</strong>.</li>
          </ol>
        </section>

        <section>
          <h2>Phân tích từ vựng và cú pháp</h2>
          <ul>
            <li><strong>Scanner</strong>: đọc ký tự, nhóm thành token (định danh, số, từ khóa, toán tử, dấu chấm phẩy, v.v.).</li>
            <li><strong>Parser</strong>: dùng văn phạm để xây cây dẫn xuất từ dãy token. Nếu không xây được → báo lỗi cú pháp.</li>
            <li>Cây dẫn xuất (sau khi bỏ bớt chi tiết) trở thành <strong>cây cú pháp trừu tượng (AST)</strong>, dùng cho các giai đoạn sau.</li>
          </ul>
        </section>

        <section>
          <h2>Bảng ký hiệu (symbol table)</h2>
          <ul>
            <li>Lưu thông tin gắn với mỗi tên: kiểu, nơi khai báo, phạm vi, v.v.</li>
            <li>Dùng trong phân tích ngữ nghĩa và sinh mã (truy cập biến theo offset, kiểm tra kiểu).</li>
          </ul>
        </section>

        <section>
          <h2>Ngữ nghĩa hình thức</h2>
          <p>Mô tả ngữ nghĩa cần vừa chính xác vừa linh hoạt (không gắn chặt một máy cụ thể). Hai họ phương pháp chính:</p>
          <ul>
            <li><strong>Denotational semantics</strong>: ý nghĩa chương trình là hàm toán học (input → output) trên các cấu trúc như môi trường, bộ nhớ.</li>
            <li><strong>Operational semantics</strong>: mô tả hành vi máy trừu tượng bằng các bước chuyển trạng thái (transition).</li>
          </ul>
        </section>

        <section>
          <h2>SOS – Structured Operational Semantics</h2>
          <p>Ví dụ kỹ thuật dùng hệ thống chuyển trạng thái:</p>
          <ul>
            <li><strong>Trạng thái</strong> \(\sigma\): ánh xạ biến → giá trị (bộ nhớ đơn giản).</li>
            <li><strong>Chuyển</strong> dạng \((c, \sigma) \to \tau\) hoặc \((c, \sigma) \to (c', \sigma')\): một bước thực thi lệnh \(c\).</li>
            <li>Quy tắc cho từng cấu trúc (skip, gán, if, while, seq) định nghĩa đệ quy ý nghĩa thực thi.</li>
          </ul>
        </section>

        <section>
          <h2>Ví dụ quy tắc SOS: skip và gán</h2>
          <pre><code>(skip, σ) → σ

(σ(X) xác định)  ⇒  (X := n, σ) → σ[X←n]</code></pre>
          <p>Điều kiện: dạng phân số (premise / conclusion) để mô tả quy tắc suy diễn.</p>
        </section>

        <section>
          <h2>Ví dụ quy tắc SOS: if và while</h2>
          <p>Nếu điều kiện true thì thực thi nhánh then, nếu false thì nhánh else. Vòng lặp while được mở thành if + seq + while (đệ quy).</p>
          <p>Từ đó có thể suy ra cả chuỗi chuyển trạng thái cho một chương trình và trạng thái cuối (nếu kết thúc).</p>
        </section>

        <section>
          <h2>Tính toán kết thúc và phân kỳ</h2>
          <ul>
            <li><strong>Tính toán kết thúc</strong>: dãy chuyển hữu hạn dẫn đến trạng thái không còn lệnh nào (chỉ còn \(\sigma\)).</li>
            <li><strong>Tính toán phân kỳ</strong>: dãy chuyển vô hạn (ví dụ while true do skip).</li>
          </ul>
        </section>

        <section>
          <h2>Ví dụ trạng thái và chuyển (SOS)</h2>
          <p>Trạng thái \(\sigma = [(X, 3), (Y, 5)]\). Sau <span class="inline-code">X := 7</span> thì \(\sigma' = [(X, 7), (Y, 5)]\). Chuyển: \((X := 7, \sigma) \to \sigma'\). Vòng lặp while được mở thành if + seq + while (đệ quy trên trạng thái và lệnh còn lại).</p>
        </section>

        <section>
          <h2>Pragmatics và Implementation</h2>
          <ul>
            <li><strong>Pragmatics</strong>: trả lời “cấu trúc này dùng để làm gì?”; gắn với phong cách lập trình và kỹ thuật phần mềm.</li>
            <li><strong>Implementation</strong>: xây trình biên dịch/thông dịch và máy trừu tượng; thường kết hợp biên dịch + thực thi (mã trung gian, RTS).</li>
          </ul>
        </section>

        <section>
          <h2>Tóm tắt – Mô tả ngôn ngữ</h2>
          <ul>
            <li>Phân biệt cú pháp, ngữ nghĩa tĩnh, ngữ nghĩa động, pragmatics, implementation.</li>
            <li>Văn phạm phi ngữ cảnh: công cụ chuẩn cho cú pháp; dẫn xuất và cây dẫn xuất; nhập nhằng và cách tránh.</li>
            <li>Trình biên dịch: lexical → syntax → semantic → intermediate/optimisation → code generation.</li>
            <li>Ngữ nghĩa hình thức: denotational vs operational; SOS dùng chuyển trạng thái để định nghĩa hành vi.</li>
          </ul>
        </section>
      </section>

      <!-- PHẦN 2: TÊN VÀ MÔI TRƯỜNG -->
      <section>
        <section>
          <h1>
            <span class="text-light">2.</span><br />
            Tên và môi trường
          </h1>
        </section>

        <section>
          <h2>Tên và đối tượng biểu thị</h2>
          <ul>
            <li><strong>Tên (name)</strong>: chuỗi ký tự dùng để chỉ một đối tượng khác (biến, thủ tục, kiểu, hằng, …).</li>
            <li><strong>Đối tượng biểu thị (denotable object)</strong>: đối tượng có thể gán cho một tên (biến, tham số, thủ tục/hàm, kiểu do người dùng định nghĩa, nhãn, mô-đun, hằng, ngoại lệ; cũng như các đối tượng định nghĩa sẵn của ngôn ngữ).</li>
          </ul>
        </section>

        <section>
          <h2>Tên ≠ Đối tượng</h2>
          <ul>
            <li>Một tên có thể chỉ nhiều đối tượng ở những vị trí khác nhau trong chương trình (che khuất).</li>
            <li>Một đối tượng có thể có nhiều tên (aliasing, ví dụ tham số truyền theo tham chiếu).</li>
            <li>Liên kết tên–đối tượng được tạo ở nhiều thời điểm: thiết kế ngôn ngữ, viết chương trình, biên dịch, thời gian chạy.</li>
          </ul>
        </section>

        <section>
          <h2>Môi trường (environment)</h2>
          <div class="question-box">
            <div class="question-title">Định nghĩa</div>
            <span class="keyword">Môi trường (tham chiếu)</span> tại một điểm trong chương trình và tại một thời điểm thực thi là tập các liên kết giữa tên và đối tượng biểu thị đang có hiệu lực tại đó.
          </div>
          <p>Môi trường không tồn tại ở mức máy vật lý; nó là bộ phận của máy trừu tượng, được mô phỏng bởi mỗi hiện thực ngôn ngữ.</p>
        </section>

        <section>
          <h2>Sơ đồ tên – môi trường – đối tượng</h2>
          <div style="display:flex;justify-content:center;gap:1.5rem;flex-wrap:wrap;font-size:0.9em;">
            <div style="border:2px solid #1E93AB;padding:0.5rem 1rem;border-radius:8px;">Tên (chuỗi ký tự)</div>
            <span>→</span>
            <div style="border:2px solid #666;padding:0.5rem 1rem;border-radius:8px;">Môi trường (liên kết)</div>
            <span>→</span>
            <div style="border:2px solid #E62727;padding:0.5rem 1rem;border-radius:8px;">Đối tượng biểu thị</div>
          </div>
          <p style="margin-top:1rem;">Môi trường tại mỗi điểm chương trình quyết định “tên này hiện trỏ tới đối tượng nào”.</p>
        </section>

        <section>
          <h2>Khai báo (declaration)</h2>
          <ul>
            <li>Khai báo là cấu trúc đưa một liên kết tên–đối tượng vào môi trường.</li>
            <li>Ví dụ: khai báo biến <span class="inline-code">int x;</span>, khai báo hàm <span class="inline-code">int f() { ... }</span>, khai báo kiểu <span class="inline-code">type T = int;</span>.</li>
            <li>Một số ngôn ngữ cho phép khai báo ngầm (tên được tạo khi lần đầu gán).</li>
          </ul>
        </section>

        <section>
          <h2>Khối (block)</h2>
          <div class="question-box">
            <div class="question-title">Định nghĩa</div>
            Một <span class="keyword">khối</span> là vùng văn bản chương trình, được xác định bởi dấu bắt đầu và kết thúc, có thể chứa các khai báo cục bộ (chỉ hiệu lực trong vùng đó).
          </div>
          <p>Ví dụ: <span class="inline-code">{ int a; int b; ... }</span> (C/Java); thụt lề trong Python; <span class="inline-code">begin ... end</span> trong Pascal.</p>
        </section>

        <section>
          <h2>Hai loại khối</h2>
          <ul>
            <li><strong>Khối gắn với thủ tục/hàm</strong>: thân thủ tục (kể cả khai báo tham số hình thức).</li>
            <li><strong>Khối dòng (in-line block)</strong>: khối không phải thân thủ tục, có thể xuất hiện ở chỗ có thể đặt lệnh.</li>
          </ul>
        </section>

        <section>
          <h2>Khối lồng nhau</h2>
          <ul>
            <li>Nhiều ngôn ngữ cho phép khối lồng nhau: định nghĩa một khối nằm trọn trong khối khác.</li>
            <li>Không cho phép “mở A, mở B, đóng A, đóng B” — thứ tự đóng phải ngược với thứ tự mở (LIFO).</li>
          </ul>
        </section>

        <section>
          <h2>Quy tắc hiển thị (visibility) cơ bản</h2>
          <p>Tên cục bộ của khối \(B\):</p>
          <ul>
            <li>Hiển thị trong \(B\) và trong mọi khối lồng trong \(B\).</li>
            <li>Trừ khi có khai báo mới cùng tên bên trong — khi đó khai báo mới che (hide) khai báo ngoài; khi ra khỏi khối trong, khai báo ngoài lại có hiệu lực.</li>
          </ul>
        </section>

        <section>
          <h2>Ba thành phần môi trường</h2>
          <ul>
            <li><strong>Môi trường cục bộ</strong>: liên kết cho các tên khai báo trong khối (và tham số hình thức nếu là khối thủ tục).</li>
            <li><strong>Môi trường không cục bộ</strong>: liên kết cho tên nhìn thấy từ trong khối nhưng không khai báo tại đó (kế thừa từ khối bên ngoài).</li>
            <li><strong>Môi trường toàn cục</strong>: liên kết có thể dùng ở mọi khối (thường là tên khai báo ở mức chương trình hoặc nhập từ mô-đun).</li>
          </ul>
        </section>

        <section>
          <h2>Thao tác trên môi trường</h2>
          <p>Khi vào khối: tạo liên kết cho tên cục bộ; tạm vô hiệu hóa liên kết của tên bị che. Khi ra khỏi khối: hủy liên kết cục bộ; khôi phục liên kết đã bị che.</p>
          <p>Thao tác trên đối tượng: tạo/hủy đối tượng (cấp phát/thu hồi bộ nhớ), truy cập và sửa đổi giá trị (nếu đối tượng cho phép).</p>
        </section>

        <section>
          <h2>Phạm vi (scope)</h2>
          <p><strong>Phạm vi của một khai báo</strong>: phần chương trình trong đó khai báo đó được coi là hiển thị (theo quy tắc của ngôn ngữ).</p>
          <p>Quy tắc xác định phạm vi gọi là <strong>quy tắc phạm vi (scope rules)</strong>. Hai dạng chính: <strong>phạm vi tĩnh (static/lexical)</strong> và <strong>phạm vi động (dynamic)</strong>.</p>
        </section>

        <section>
          <h2>Hai cách hiểu “lồng nhau”</h2>
          <ul>
            <li><strong>Tĩnh (theo văn bản)</strong>: khối B lồng trong A nếu trong mã nguồn, B nằm trọn trong A.</li>
            <li><strong>Động (theo thời gian)</strong>: “khối gần nhất” là khối vừa được vào (kích hoạt) và chưa ra.</li>
          </ul>
          <p>Quy tắc phạm vi tĩnh dùng cách hiểu thứ nhất; quy tắc phạm vi động dùng cách thứ hai.</p>
        </section>

        <section>
          <h2>Phạm vi tĩnh (static scope)</h2>
          <ul>
            <li>Liên kết hợp lệ cho một tên tại điểm \(P\) chỉ phụ thuộc vào <strong>cấu trúc văn bản</strong> chương trình (khối nào chứa \(P\), khối nào chứa khai báo).</li>
            <li>Trình biên dịch có thể xác định được “tên này trỏ tới khai báo nào” khi biên dịch.</li>
            <li>Quy tắc điển hình: <strong>nearest nested scope</strong> — tìm từ khối hiện tại ra ngoài, chọn khai báo gần nhất.</li>
          </ul>
        </section>

        <section>
          <h2>Ví dụ phạm vi tĩnh</h2>
          <pre><code>A: { int x = 0;
  void fie() { x = 1; }
  B: { int x;
       fie();
     }
  write(x);
}</code></pre>
          <p>Trong <span class="inline-code">fie</span>, <span class="inline-code">x</span> theo phạm vi tĩnh là <span class="inline-code">x</span> của khối A (nơi khai báo <span class="inline-code">fie</span>). Sau <span class="inline-code">fie()</span>, <span class="inline-code">write(x)</span> in 1.</p>
        </section>

        <section>
          <h2>Phạm vi động (dynamic scope)</h2>
          <ul>
            <li>Liên kết hợp lệ cho tên \(X\) tại điểm \(P\) là <strong>liên kết được tạo gần nhất (theo thời gian) cho \(X\)</strong> mà vẫn còn hiệu lực khi điều khiển tới \(P\).</li>
            <li>Phụ thuộc thứ tự gọi/ vào–ra khối lúc chạy, không chỉ cấu trúc văn bản.</li>
          </ul>
        </section>

        <section>
          <h2>Ví dụ phạm vi động</h2>
          <p>Cùng đoạn mã: khi gọi <span class="inline-code">fie()</span> từ trong B, “x gần nhất còn hoạt động” có thể là <span class="inline-code">x</span> của B. Khi đó <span class="inline-code">fie()</span> gán 1 cho x của B; sau khi ra B, <span class="inline-code">write(x)</span> in x của A (vẫn 0). Kết quả in ra khác phạm vi tĩnh.</p>
        </section>

        <section>
          <h2>So sánh phạm vi tĩnh và động</h2>
          <table>
            <thead>
              <tr><th>Tiêu chí</th><th>Phạm vi tĩnh</th><th>Phạm vi động</th></tr>
            </thead>
            <tbody>
              <tr><td>Xác định bởi</td><td>Cấu trúc văn bản</td><td>Thứ tự kích hoạt lúc chạy</td></tr>
              <tr><td>Thời điểm xác định</td><td>Biên dịch</td><td>Thời gian chạy</td></tr>
              <tr><td>Hiệu quả truy cập</td><td>Tốt (offset/static chain)</td><td>Thường kém hơn (tìm trên stack/A-list)</td></tr>
              <tr><td>Đọc chương trình</td><td>Dễ suy luận theo văn bản</td><td>Khó hơn, phụ thuộc luồng gọi</td></tr>
            </tbody>
          </table>
        </section>

        <section>
          <h2>Một số vấn đề phạm vi</h2>
          <ul>
            <li><strong>Phạm vi bắt đầu từ đâu</strong>: C/Java — từ điểm khai báo đến hết khối; Python — toàn bộ khối (nhưng “gán trước khi dùng” có thể gây ngoại lệ).</li>
            <li><strong>Hàm đệ quy tương hỗ</strong>: cần khai báo trước (forward declaration) hoặc cơ chế cho phép tham chiếu trước định nghĩa.</li>
          </ul>
        </section>

        <section>
          <h2>Câu hỏi nhanh – Phạm vi</h2>
          <ol>
            <li>Trong phạm vi tĩnh, trình biên dịch có thể biết “offset” của biến cục bộ trong activation record không? Còn biến không cục bộ?</li>
            <li>Tại sao phạm vi động thường kém hiệu quả hơn khi truy cập biến không cục bộ?</li>
            <li>Cho ví dụ một tên có phạm vi chỉ trong một phần của khối (từ điểm khai báo đến hết khối).</li>
          </ol>
        </section>

        <section>
          <h2>Aliasing và dangling reference</h2>
          <ul>
            <li><strong>Aliasing</strong>: cùng một đối tượng (ví dụ ô nhớ) có thể truy cập qua nhiều tên (tham số tham chiếu, con trỏ). Cần cẩn thận khi sửa qua một tên ảnh hưởng tới tên kia.</li>
            <li><strong>Dangling reference</strong>: tên hoặc con trỏ vẫn trỏ tới vùng nhớ đã bị thu hồi → truy cập không hợp lệ. Là lỗi lập trình cần tránh.</li>
          </ul>
        </section>

        <section>
          <h2>Tóm tắt – Tên và môi trường</h2>
          <ul>
            <li>Tên và đối tượng biểu thị; môi trường là tập liên kết tên–đối tượng có hiệu lực tại một điểm và thời điểm.</li>
            <li>Khối và hai loại khối; quy tắc hiển thị; ba thành phần môi trường (cục bộ, không cục bộ, toàn cục).</li>
            <li>Phạm vi tĩnh (lexical) vs động; ưu nhược điểm và ví dụ.</li>
            <li>Một số vấn đề: phạm vi theo điểm khai báo, đệ quy tương hỗ, aliasing, dangling reference.</li>
          </ul>
        </section>
      </section>

      <!-- TỔNG KẾT -->
      <section>
        <section style="font-size: 0.85em;">
          <h2>Tổng kết</h2>
          <ul>
            <li><strong>Mô tả ngôn ngữ</strong>: cú pháp (văn phạm phi ngữ cảnh, dẫn xuất, cây, nhập nhằng), ngữ nghĩa tĩnh, ngữ nghĩa động; cấu trúc trình biên dịch; ngữ nghĩa hình thức (SOS).</li>
            <li><strong>Tên và môi trường</strong>: đối tượng biểu thị, môi trường, khối, visibility; phạm vi tĩnh và động; thao tác trên môi trường và một số vấn đề phạm vi.</li>
          </ul>
        </section>
      </section>

      <div class="footer">
        Phương pháp luận lập trình (Học kỳ 2 2025-2026) §2a: Cú pháp, ngữ nghĩa, tên và phạm vi
      </div>
    </div>
  </div>
  <script src="revealjs/dist/reveal.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script src="plugin/math/math.js"></script>
  <script>
    Reveal.initialize({
      controlsLayout: "edges",
      slideNumber: true,
      hashOneBasedIndex: true,
      hash: true,
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX],
    });
  </script>
</body>

</html>
